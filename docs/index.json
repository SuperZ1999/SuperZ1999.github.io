[{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.","title":"LeetCode 23"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.","title":"LeetCode 86"},{"content":"思路 不解释\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } References 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-21/","summary":"思路 不解释\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.","title":"LeetCode 21"}]
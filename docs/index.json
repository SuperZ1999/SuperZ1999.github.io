[{"content":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public boolean carPooling(int[][] trips, int capacity) { int len = 0; for (int[] trip : trips) { len = len \u0026gt; trip[2] ? len : trip[2]; } int[] nums = new int[len]; Difference df = new Difference(nums); for (int[] trip : trips) { df.increment(trip[1], trip[2] - 1, trip[0]); } for (int num : df.result()) { if (num \u0026gt; capacity) { return false; } } return true; } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 拼车 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-1094/","summary":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public boolean carPooling(int[][] trips, int capacity) { int len = 0; for (int[] trip : trips) { len = len \u0026gt; trip[2] ?","title":"LeetCode 1094"},{"content":"思路 标准差分数组，详见LeetCode-note\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 航班预订统计 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-1109/","summary":"思路 标准差分数组，详见LeetCode-note\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.","title":"LeetCode 1109"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class NumMatrix { int[][] preSum; public NumMatrix(int[][] matrix) { preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { for (int j = 1; j \u0026lt; preSum[0].length; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } public int sumRegion(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } References 1. 二维区域和检索 - 矩阵不可变 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-304/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class NumMatrix { int[][] preSum; public NumMatrix(int[][] matrix) { preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { for (int j = 1; j \u0026lt; preSum[0].length; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } public int sumRegion(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } References 1.","title":"LeetCode 304"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } References 1. 区域和检索 - 数组不可变 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-303/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } References 1.","title":"LeetCode 303"},{"content":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.charAt(left); left++; window.put(d, window.get(d) - 1); } ans = Integer.max(ans, right - left); } return ans; } } References 1. 无重复字符的最长子串 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-3/","summary":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.","title":"LeetCode 3"},{"content":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-567/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; p.length(); i++) { char c = p.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == p.length()) { ans.add(left); char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } } return ans; } } 另一种思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 vector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector\u0026lt;int\u0026gt; res; // 记录结果 while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } References 1. 找到字符串中所有字母异位词 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-438/","summary":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-567/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; p.length(); i++) { char c = p.","title":"LeetCode 438"},{"content":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法的字符，当窗口的长度和s1的长度一样时，就找到了这个子串\nlabuladong的思路：利用滑动窗口的思想，始终保持窗口大小为s1.size()-1，每次移入窗口一个元素，检查一下是否找到子串，如果没有，再让一个元素移出窗口，直到找到这个子串\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s1.length(); i++) { char c = s1.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; while (right \u0026lt; s2.length()) { char c = s2.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s2.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == s1.length()) { return true; } } return false; } } 另一种思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } // 未找到符合条件的子串 return false; } References 1. 字符串的排列 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-567/","summary":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法的字符，当窗口的长度和s1的长度一样时，就找到了这个子串\nlabuladong的思路：利用滑动窗口的思想，始终保持窗口大小为s1.size()-1，每次移入窗口一个元素，检查一下是否找到子串，如果没有，再让一个元素移出窗口，直到找到这个子串\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s1.length(); i++) { char c = s1.","title":"LeetCode 567"},{"content":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { char c = t.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, valid = 0, begin = 0, end = Integer.MAX_VALUE; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素 // 所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) { valid++; } } while (valid == need.size()) { if (end - begin \u0026gt; right - left) { begin = left; end = right; } c = s.charAt(left); left++; if (need.containsKey(c)) { if (window.get(c).equals(need.get(c))) { valid--; } window.put(c, window.get(c) - 1); } } } return end == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(begin, end); } } References 1. 最小覆盖子串 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-76/","summary":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.","title":"LeetCode 76"},{"content":"思路 第一题 排序，不解释\n第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了\n第三题 暴力会超时，利用动态规划的思想，从左往右遍历一遍找各元素左边递减的元素个数，从右往左遍历一遍找各元素右边递增的元素个数，然后和k比较就可以了\n我的代码 第一题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public String[] sortPeople(String[] names, int[] heights) { People[] peoples = new People[names.length]; for(int i = 0; i \u0026lt; peoples.length; i++) { peoples[i] = new People(names[i], heights[i]); } Arrays.sort(peoples, (a, b) -\u0026gt; b.height - a.height); for (int i = 0; i \u0026lt; peoples.length; i++) { names[i] = peoples[i].name; } return names; } static class People { String name; int height; public People(String name, int height) { this.name = name; this.height = height; } } } 第二题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int longestSubarray(int[] nums) { int max = Integer.MIN_VALUE, ans = 0, count = 0; for (int num : nums) { if (num != max) { count = 0; if (num \u0026gt; max) { max = num; ans = 0; } } if (num == max) { count++; } if (count \u0026gt; ans) { ans = count; } } return ans; } } 第三题 动态规划：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { int[] decre = new int[nums.length]; decre[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026lt;= nums[i - 1]) { decre[i] = decre[i - 1] + 1; } else { decre[i] = 1; } } int[] incre = new int[nums.length]; incre[nums.length - 1] = 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { if (nums[i] \u0026lt;= nums[i + 1]) { incre[i] = incre[i + 1] + 1; } else { incre[i] = 1; } } ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (decre[i - 1] \u0026gt;= k \u0026amp;\u0026amp; incre[i+1] \u0026gt;= k) { ans.add(i); } } return ans; } } 暴力解法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { private boolean isGoodIndex(int[] nums, int index, int k) { for (int i = index - 1; i \u0026gt; index - k; i--) { if (nums[i] \u0026gt; nums[i - 1]) { return false; } } for (int i = index + 1; i \u0026lt; index + k; i++) { if (nums[i] \u0026gt; nums[i + 1]) { return false; } } return true; } public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (isGoodIndex(nums, i, k)) { ans.add(i); } } return ans; } } References 1. 按身高排序 2. 按位与最大的最长子数组 3. 找到所有好下标 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-%E5%91%A8%E8%B5%9B-312/","summary":"思路 第一题 排序，不解释\n第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了\n第三题 暴力会超时，利用动态规划的思想，从左往右遍历一遍找各元素左边递减的元素个数，从右往左遍历一遍找各元素右边递增的元素个数，然后和k比较就可以了\n我的代码 第一题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public String[] sortPeople(String[] names, int[] heights) { People[] peoples = new People[names.length]; for(int i = 0; i \u0026lt; peoples.length; i++) { peoples[i] = new People(names[i], heights[i]); } Arrays.sort(peoples, (a, b) -\u0026gt; b.height - a.","title":"LeetCode 周赛-312"},{"content":"思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，分别查找左边界或右边界即可，详见LeetCode-note\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026gt; nums[mid]) { left = mid + 1; } else { right = mid; } } if (nums[left] != target) { return new int[]{-1, -1}; } int[] ans = new int[2]; ans[0] = left; left = 0; right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid; } } ans[1] = left; return ans; } } References 1. 在排序数组中查找元素的第一个和最后一个位置 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-34/","summary":"思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，分别查找左边界或右边界即可，详见LeetCode-note\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026gt; nums[mid]) { left = mid + 1; } else { right = mid; } } if (nums[left] !","title":"LeetCode 34"},{"content":"思路 经典二分查找，不解释\n详见：https://labuladong.gitee.io/algo/2/20/29/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } } References 1. 二分查找 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-704/","summary":"思路 经典二分查找，不解释\n详见：https://labuladong.gitee.io/algo/2/20/29/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } } References 1.","title":"LeetCode 704"},{"content":"思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String s1 = findPalindrome(s, i, i); String s2 = findPalindrome(s, i, i + 1); res = res.length() \u0026gt;= s1.length() ? res : s1; res = res.length() \u0026gt;= s2.length() ? res : s2; } return res; } private String findPalindrome(String s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(left) == s.charAt(right)) { left--; right++; } return s.substring(left + 1, right); } } References 1. 最长回文子串 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-5/","summary":"思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String s1 = findPalindrome(s, i, i); String s2 = findPalindrome(s, i, i + 1); res = res.length() \u0026gt;= s1.length() ? res : s1; res = res.","title":"LeetCode 5"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 反转字符串 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-344/","summary":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 反转字符串 ","title":"LeetCode 344"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return new int[]{left + 1, right + 1}; } } return new int[]{0, 0}; } } References 1. 两数之和 II - 输入有序数组 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-167/","summary":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return new int[]{left + 1, right + 1}; } } return new int[]{0, 0}; } } References 1.","title":"LeetCode 167"},{"content":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题）\n26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n83 同26，只不过是链表，要注意去重后要把slow后面的链表断开，否则slow后面可能会有和slow重复的。\n27 同26，只不过不是比较slow和fast的元素，而是让fast和确定的值比较。\n283 同27，只不过得把slow后面的改成0。\n我的代码 26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } } 83 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { slow.next = fast; slow = slow.next; } fast = fast.next; } slow.next = null; return head; } } 27 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int removeElement(int[] nums, int val) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } 283 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void moveZeroes(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != 0) { nums[slow] = nums[fast]; slow++; } fast++; } while (slow \u0026lt; nums.length) { nums[slow] = 0; slow++; } } } References 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-26+83+27+283/","summary":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题）\n26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n83 同26，只不过是链表，要注意去重后要把slow后面的链表断开，否则slow后面可能会有和slow重复的。\n27 同26，只不过不是比较slow和fast的元素，而是让fast和确定的值比较。\n283 同27，只不过得把slow后面的改成0。\n我的代码 26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } } 83 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast !","title":"LeetCode 26+83+27+283"},{"content":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找中点 ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // 如果是奇数个节点，slow需要后移一位 if (fast != null) { slow = slow.next; } // 反转slow之后的 ListNode right = reverse(slow), left = head; // 判断回文 while (right != null) { if (left.val != right.val) { return false; } left = left.next; right = right.next; } return true; } private ListNode reverse(ListNode head) { ListNode pre = null, cur = head; while (cur != null) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88+%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找中点 ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.","title":"LeetCode 234 快慢指针+反转链表"},{"content":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private boolean traverse(ListNode right) { if (right == null) { return true; } boolean res = traverse(right.next); res = res \u0026amp;\u0026amp; (left.val == right.val); left = left.next; return res; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private boolean traverse(ListNode right) { if (right == null) { return true; } boolean res = traverse(right.next); res = res \u0026amp;\u0026amp; (left.val == right.val); left = left.next; return res; } } References 1.","title":"LeetCode 234 链表后序遍历"},{"content":"思路 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { private ListNode reverse(ListNode a, ListNode b) { // 这个做法需要对第一个节点特殊判断 // if (head == null) { // return null; // } // // ListNode pre = head, cur = head.next; // head.next = null; // while (cur != null) { // ListNode temp = cur.next; // cur.next = pre; // cur = temp; // } // // return pre; // 这个做法不需要对第一个节点特殊判断 ListNode pre = null, cur = a; while (cur != b) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } public ListNode reverseKGroup(ListNode head, int k) { ListNode p = head; // 找出前k个节点，不满k个直接return for (int i = 0; i \u0026lt; k; i++) { if (p == null) { return head; } p = p.next; } // 反转前k个 ListNode newHead = reverse(head, p); // 拼接后面反转后的链表 head.next = reverseKGroup(p, k); return newHead; } } References 1. K 个一组翻转链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-25/","summary":"思路 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { private ListNode reverse(ListNode a, ListNode b) { // 这个做法需要对第一个节点特殊判断 // if (head == null) { // return null; // } // // ListNode pre = head, cur = head.","title":"LeetCode 25"},{"content":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } public ListNode reverseBetween(ListNode head, int left, int right) { if (left == 1) { return reverseN(head, right); } head.next = reverseBetween(head.next, left - 1, right - 1); return head; } } References 1. 反转链表 II ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-92/","summary":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } public ListNode reverseBetween(ListNode head, int left, int right) { if (left == 1) { return reverseN(head, right); } head.","title":"LeetCode 92"},{"content":"思路 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } } ","permalink":"https://blog.zhangmengyang.tk/leetcodes/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"思路 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.","title":"反转链表前n个节点"},{"content":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } } References 1. 反转链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-206/","summary":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } } References 1. 反转链表 ","title":"LeetCode 206"},{"content":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n分析过程 难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n转载于： https://labuladong.gitee.io/algo/2/19/18/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } } References 1. 相交链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-160/","summary":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n分析过程 难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n转载于： https://labuladong.gitee.io/algo/2/19/18/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 !","title":"LeetCode 160"},{"content":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n分析过程 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：\nfast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。\n假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。\n转载于：https://labuladong.gitee.io/algo/2/19/18/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; // 寻找相遇点 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) { break; } } if (fast == null || fast.next == null) { return null; } // 再次相遇即为环起始点 fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } References 1. 环形链表 II ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-142/","summary":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n分析过程 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：\nfast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。\n假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。\n转载于：https://labuladong.gitee.io/algo/2/19/18/\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; // 寻找相遇点 while (fast !","title":"LeetCode 142"},{"content":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表有环 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } References 1. 环形链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-141/","summary":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表有环 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } References 1. 环形链表 ","title":"LeetCode 141"},{"content":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; // 经典快慢指针 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } References 1. 链表的中间结点 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-876/","summary":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; // 经典快慢指针 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } References 1. 链表的中间结点 ","title":"LeetCode 876"},{"content":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; // 找到倒数第n+1个节点 ListNode node = findFromEnd(dummy, n + 1); node.next = node.next.next; return dummy.next; } } References 1. 删除链表的倒数第 N 个结点 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-19/","summary":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 !","title":"LeetCode 19"},{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.","title":"LeetCode 23"},{"content":"链表 合并两个有序链表 解法 略\n题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-21/\n单链表的分解 解法 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n题目 1. 分隔链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-86/\n合并 k 个有序链表 解法 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n题目 1. 合并K个升序链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-23/\n寻找单链表的倒数第 k 个节点 解法 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n题目 1. 删除链表的倒数第 N 个结点 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-19/\n单链表的中点 解法 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n题目 1. 链表的中间结点 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-876/\n判断链表是否包含环 解法 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n题目 1. 环形链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-141/\n存在环的链表中寻找环起点 解法 利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n题目 1. 环形链表 II 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-142/\n判断两个链表是否相交 解法 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n题目 1. 相交链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-160/\n反转单链表 解法 利用递归的思想，先反转head后面的，然后把head也反转即可。\n思想 反转的过程就是改变指针方向的过程并且最后一个指向null，比如反转第2个\u0026mdash;第5个：\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null\n反转后为：\n1 -\u0026gt; 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5\n​\tnull\n题目 1. 反转链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-206/\n反转链表前n个节点 解法 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n题目 无\n题解详见：https://blog.zhangmengyang.tk/leetcodes/反转链表前n个节点/\n反转链表节点(m, n) 解法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n题目 1. 反转链表 II 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-92/\nK 个一组翻转链表 解法 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n题目 1. K 个一组翻转链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-25/\n链表的前后序遍历 1 2 3 4 5 void traverse(ListNode head) { // 前序遍历代码 traverse(head.next); // 后序遍历代码 } 回文串 寻找回文串 核心思想是从中心向两端扩展\n判断回文串 核心思想是从两端向中间逼近\n判断回文链表 解法 可以将链表全部反转，也可以部分反转\n链表全部反转 链表全部反转的方法共3种：\n将原链表反转，然后与原链表比较 略\n链表后序遍历 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-234-链表后序遍历/\n利用栈 同链表后序遍历\n链表部分反转 快慢指针+反转链表 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-234-快慢指针+反转链表/\n题目 1. 回文链表 数组 快慢指针在数组中的应用 数组元素去重 解法 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n具体变种详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-26+83+27+283/\n题目 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 滑动窗口 解法 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n详见思想章节\n题目 1. 最小覆盖子串 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-76/\n2. 字符串的排列 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-567/\n3. 找到字符串中所有字母异位词 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-438/\n4. 无重复字符的最长子串 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-3/\n左右指针在数组中的应用 二分查找 解法 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度，详见思想章节\n题目 1. 在排序数组中查找元素的第一个和最后一个位置 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-34/\n2. 二分查找 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-704/\n两数之和 解法 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n题目 1. 两数之和 II - 输入有序数组 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-167/\n反转数组 解法 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n题目 1. 反转字符串 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-344/\n回文串判断 解法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n题目 1. 最长回文子串 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-5/\n前缀和在数组里的应用 一维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的时nums前n个元素的和，整体往后挪一位\n题目 1. 区域和检索 - 数组不可变 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-303/\n二维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n题目 1. 二维区域和检索 - 矩阵不可变 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-304/\n差分数组 解法 详见思想章节\n题目 1. 航班预订统计 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-1109/\n1. 拼车 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-1094/\n思想 双指针 就是两个指针，分为左右指针和快慢指针，只要数组有序，就应该想到双指针技巧\n左右指针 两个指针一个左一个右\n二分查找 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度\n经典思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } 这种就是一边缩减搜索空间，一边寻找要找的元素。\n但是有时候问题并不是这么简单，比如寻找一个可能在数组里不存在，或者是找边界这样的问题，这时使用进阶思路 ，在循环体内排除一定不存在目标元素的区间会更简单一些。\n经典思路是寻找元素\n进阶思路是排除n-1个不可能的元素\n进阶思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public int search(int[] nums, int target) { // 此思路搜索空间为[left, right]，闭闭空间 int left = 0, right = nums.length - 1; // 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，那么一定会达到left和right重合的状态 // 所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right while (left \u0026lt; right) { // 求中点，left=mid+1时不需要向上取整 int mid = left + (right - left) / 2; // left=mid时需要向上取整，记忆方式：left和mid要有一个+1 // 这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left //int mid = left + (right - left + 1) / 2; // 下面是核心逻辑，分成两个区间是因为这样扩展性更强 // 这块主要就是筛选不可能的区间，然后缩减搜索空间，具体问题具体分析，注意left没加一时mid要加一 if (target \u0026gt; nums[mid]) { left = mid + 1; } else { right = mid; } /*if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; }*/ /*if (target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid; }*/ /*if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid -1; }*/ } // 此时left一定等于right，所以返回left或者right都一样 // 排除了n-1个不可能的元素，还剩下[left, right]区间的元素，而left=right，就看剩下这个是不是要寻找的元素了 // 如果该题一定存在指定的元素，那么下一步可以省略，直接return left就好了 if (nums[left] == target) { return left; } return -1; } } 步骤 left和right分别设置为搜索空间的左右端点，注意是闭区间 循环条件写成left\u0026lt;right 求中点，先写成int mid = left + (right - left) / 2; 根据具体问题将搜索空间分成两部分，其中一部分必须是不可能的区域，然后根据这个不可能区域的特征写出第一个if，然后else里写和if互补的区域就好了，注意如果结果是left=mid，上面求中点要改成int mid = left + (right - left + 1) / 2; 如果根据题意不能判断出一定存在寻找的元素，需要判断下nums[left]是不是寻找的元素，是则return left，否则未找到该元素；如果根据题意能判断出一定存在寻找的元素，那直接return left就好了 注意点 此思路搜索空间为[left, right]，闭闭空间 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，并且根据left的取值选择mid是向上或向下取整，那么一定会达到left和right重合的状态（把所有情况都模拟一边就可以得出这个结论），所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right 求中点时，如果使用(left + right) / 2有可能相加溢出，为了防止溢出使用left + (right - left) / 2 求中点时，left=mid+1时不需要向下取整，left=mid时需要向上取整，记忆方式：left和mid要有一个+1。这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left。right=mid时需要向下取整，原因同理 把搜索空间分成两个区间是因为这样扩展性更强 缩减搜索空间时，将搜索空间分成两部分需要注意分出不可能的区间，然后缩减搜索空间，具体问题具体分析，根据这个不可能区间的特征写出第一个if，然后else里写和if互补的区域 注意left没加一时mid要加一 退出循环后left和right相等，并且是唯一有希望的元素（只是有希望，有可能不是它，还要再判断一下，如果该题一定存在指定的元素，那么直接return left就好了） 对于寻找左右侧边界的二分查找，在缩减搜索空间时一定要考虑\u0026gt;=或\u0026lt;=的情况，因为这样才能使用找左或右侧这个性质，比如target \u0026lt;= nums[mid]，可以寻找左边界，因为这时左边界不可能在mid右边所以直接right=mid就可以找到左边界，右边界同理。为什么找到的是左边界，也可以这么理解：target \u0026lt;= nums[mid]-\u0026gt;right=mid，所以target \u0026gt; nums[mid]-\u0026gt;left=mid + 1，此时left左边全部都小于target，因为退出循环时如果能找到target，left指向的就是target，又因为left左边全部都小于target，所以此时left指向左边界。找右边界同理。 详见：leetcode笔记word版和https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/\n其他 见上面各知识点章节\n快慢指针 两个指针一个快一个慢\n滑动窗口 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 滑动窗口算法模板 */ void slidingWindow(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素，所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { // 获取移入窗口的元素，并扩大窗口 char c = s.charAt(right); right++; // 进行扩大窗口时数据的一系列更新 ... // debug位置 // System.out.println(\u0026#34;left:\u0026#34; + left + \u0026#34;\\t\u0026#34; + \u0026#34;right:\u0026#34; + right); // 判断左侧窗口是否要收缩 while (window needs shrink) { // 获取移出窗口的元素，并收缩窗口 char d = s.charAt(left); left++; // 进行收缩窗口时数据的一系列更新，一般与上面扩大窗口时数据更新相反 ... } } } 步骤 设置存储窗口内元素的数据结构，并且设置循环while (right \u0026lt; s.length()) 扩大窗口，并更新相关的数据 判断是否需要收缩窗口，如需要，则收缩窗口，并更新相关的数据 退出循环后，返回相应的数据 注意点 此模板采用闭开区间，循环条件用\u0026lt;而不用\u0026lt;=是因为right当前位置的元素是我们下一个要入窗口的元素 收缩窗口和扩大窗口对数据的更新一般是相反的（更新顺序和加减等都是相反的） 详见：https://labuladong.gitee.io/algo/2/20/27/\n其他 见上面各知识点章节\n递归 一个问题 = 规模更小的同类问题 + 扩展成该问题要解决的问题\n这种情况就可以用递归，递归的关键是不要跳进递归，而是明确递归函数的定义\n递归由两部分组成：递归出口和递归公式\n注意递归需要递归出口（也就是base case）\n值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。\n前缀和 对于一个数组，求此数组[left, right]区域内的和时，不需要从left\u0026ndash;right逐个相加，直接right+1前的和减去left前的和即可，要想使用这种方式就得有一个前缀和数组，用来存该数组前k个的和。注意也可能是二维数组，稍作修改即可。\n主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。\n详见：https://labuladong.gitee.io/algo/2/20/24/\n标准模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } 差分数组 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减\n类似前缀和构造的 preSum 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差，通过这个 diff 差分数组是可以反推出原始数组 nums 的，理解：diff[0]就是原数组的第一个元素，其他元素就是比前一个元素高多少\n这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可\n原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对 nums[i..j] 中的所有元素都加 3 了\n详见：https://labuladong.gitee.io/algo/2/20/25/\n标准模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } 其他 零碎 从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。\n数据结构的物理存储方式就是链式和顺序两种，基本操作就是增删改查，遍历方式无非迭代和递归。\n计算机算法的本质就是枚举，只不过这里枚举需要做到两个方面：无遗漏和无冗余，有时候还可以利用一些定理进行优化（缩小搜索范围），比如剪枝和数学定理\n难点在无遗漏的问题：\n难点在无冗余的问题：递归类问题（动态规划）\n难点在优化的问题：非递归类问题（并查集，贪心，KMP）\nJava里优先队列就是二叉堆，也就是PriorityQueue\n待做 https://labuladong.gitee.io/algo/1/3/的那几个算法框架及之后的几个框架文章都没看\n技巧 dummy（虚拟头结点)：可以很好的避免第一个节点的特殊性，将第一个节点当作第二个节点，也即是所有节点统一处理\n","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-note/","summary":"链表 合并两个有序链表 解法 略\n题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-21/\n单链表的分解 解法 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n题目 1. 分隔链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-86/\n合并 k 个有序链表 解法 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n题目 1. 合并K个升序链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-23/\n寻找单链表的倒数第 k 个节点 解法 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n题目 1. 删除链表的倒数第 N 个结点 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-19/\n单链表的中点 解法 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n题目 1. 链表的中间结点 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-876/\n判断链表是否包含环 解法 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n题目 1. 环形链表 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-141/\n存在环的链表中寻找环起点 解法 利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n题目 1. 环形链表 II 题解详见：https://blog.zhangmengyang.tk/leetcodes/leetcode-142/\n判断两个链表是否相交 解法 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：","title":"LeetCode Note"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 1. 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.","title":"LeetCode 86"},{"content":"思路 不解释\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } References 1. 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-21/","summary":"思路 不解释\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.","title":"LeetCode 21"}]
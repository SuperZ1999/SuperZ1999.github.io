[{"content":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让快指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // 快指针走到头，慢指针指向的就是需要找的节点 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; // 找到倒数第n+1个节点 ListNode node = findFromEnd(dummy, n + 1); node.next = node.next.next; return dummy.next; } } References 1. 删除链表的倒数第 N 个结点 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-19/","summary":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让快指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // 快指针走到头，慢指针指向的就是需要找的节点 while (p1 !","title":"LeetCode 19"},{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.","title":"LeetCode 23"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 1. 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.","title":"LeetCode 86"},{"content":"思路 不解释\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } References 1. 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/leetcodes/leetcode-21/","summary":"思路 不解释\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.","title":"LeetCode 21"}]
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ZMY&#39;s Blog</title>
    <link>https://blog.zhangmengyang.tk/</link>
    <description>Recent content on ZMY&#39;s Blog</description>
    <image>
      <url>https://blog.zhangmengyang.tk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.zhangmengyang.tk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 23 Sep 2022 12:32:27 +0800</lastBuildDate><atom:link href="https://blog.zhangmengyang.tk/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 19</title>
      <link>https://blog.zhangmengyang.tk/leetcodes/leetcode-19/</link>
      <pubDate>Fri, 23 Sep 2022 12:32:27 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/leetcodes/leetcode-19/</guid>
      <description>思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。
注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。
我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i &amp;lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 !</description>
    </item>
    
    <item>
      <title>LeetCode 23</title>
      <link>https://blog.zhangmengyang.tk/leetcodes/leetcode-23/</link>
      <pubDate>Fri, 23 Sep 2022 10:47:55 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/leetcodes/leetcode-23/</guid>
      <description>思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。
我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue&amp;lt;ListNode&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(lists.length, (a, b) -&amp;gt; { return a.val - b.</description>
    </item>
    
    <item>
      <title>LeetCode 86</title>
      <link>https://blog.zhangmengyang.tk/leetcodes/leetcode-86/</link>
      <pubDate>Fri, 23 Sep 2022 00:09:37 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/leetcodes/leetcode-86/</guid>
      <description>思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。
我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val &amp;lt; x) { p1.next = p; p1 = p1.next; } else { p2.</description>
    </item>
    
    <item>
      <title>LeetCode 21</title>
      <link>https://blog.zhangmengyang.tk/leetcodes/leetcode-21/</link>
      <pubDate>Thu, 22 Sep 2022 23:42:59 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/leetcodes/leetcode-21/</guid>
      <description>思路 不解释
我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null &amp;amp;&amp;amp; list2 != null) { if (list1.val &amp;lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.</description>
    </item>
    
    <item>
      <title>My 1st post</title>
      <link>https://blog.zhangmengyang.tk/posts/my-first-post/</link>
      <pubDate>Tue, 15 Sep 2020 11:30:03 +0000</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/posts/my-first-post/</guid>
      <description>Desc Text.</description>
    </item>
    
  </channel>
</rss>

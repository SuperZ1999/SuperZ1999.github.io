[{"content":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.charAt(left); left++; window.put(d, window.get(d) - 1); } ans = Integer.max(ans, right - left); } return ans; } } References 1. 无重复字符的最长子串 ","permalink":"https://blog.zhangmengyang.tk/zh/leetcodes/leetcode-3/","summary":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n我的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.","title":"LeetCode 3"}]